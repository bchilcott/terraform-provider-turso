// Code generated by ogen, DO NOT EDIT.

package client

import (
	"context"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

// handleV1AuthAPITokensGetRequest handles GET /v1/auth/api-tokens operation.
//
// Returns a list of API tokens belonging to a user.
//
// GET /v1/auth/api-tokens
func (s *Server) handleV1AuthAPITokensGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/auth/api-tokens"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1AuthAPITokensGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *V1AuthAPITokensGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1AuthAPITokensGet",
			OperationSummary: "List API Tokens",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *V1AuthAPITokensGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1AuthAPITokensGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1AuthAPITokensGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1AuthAPITokensGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1AuthAPITokensTokenNameDeleteRequest handles DELETE /v1/auth/api-tokens/{tokenName} operation.
//
// Revokes the provided API token belonging to a user.
//
// DELETE /v1/auth/api-tokens/{tokenName}
func (s *Server) handleV1AuthAPITokensTokenNameDeleteRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/auth/api-tokens/{tokenName}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1AuthAPITokensTokenNameDelete",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1AuthAPITokensTokenNameDelete",
			ID:   "",
		}
	)
	params, err := decodeV1AuthAPITokensTokenNameDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response jx.Raw
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1AuthAPITokensTokenNameDelete",
			OperationSummary: "Revoke API Token",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "tokenName",
					In:   "path",
				}: params.TokenName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1AuthAPITokensTokenNameDeleteParams
			Response = jx.Raw
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1AuthAPITokensTokenNameDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1AuthAPITokensTokenNameDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1AuthAPITokensTokenNameDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1AuthAPITokensTokenNameDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1AuthAPITokensTokenNamePostRequest handles POST /v1/auth/api-tokens/{tokenName} operation.
//
// Returns a new API token belonging to a user.
//
// POST /v1/auth/api-tokens/{tokenName}
func (s *Server) handleV1AuthAPITokensTokenNamePostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/auth/api-tokens/{tokenName}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1AuthAPITokensTokenNamePost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1AuthAPITokensTokenNamePost",
			ID:   "",
		}
	)
	params, err := decodeV1AuthAPITokensTokenNamePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response jx.Raw
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1AuthAPITokensTokenNamePost",
			OperationSummary: "Create API Token",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "tokenName",
					In:   "path",
				}: params.TokenName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1AuthAPITokensTokenNamePostParams
			Response = jx.Raw
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1AuthAPITokensTokenNamePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1AuthAPITokensTokenNamePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1AuthAPITokensTokenNamePost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1AuthAPITokensTokenNamePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1AuthValidateGetRequest handles GET /v1/auth/validate operation.
//
// Validates an API token belonging to a user.
//
// GET /v1/auth/validate
func (s *Server) handleV1AuthValidateGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/auth/validate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1AuthValidateGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *V1AuthValidateGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1AuthValidateGet",
			OperationSummary: "Validate API Token",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *V1AuthValidateGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1AuthValidateGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1AuthValidateGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1AuthValidateGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1LocationsGetRequest handles GET /v1/locations operation.
//
// Returns a list of locations where you can create or replicate databases.
//
// GET /v1/locations
func (s *Server) handleV1LocationsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/locations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1LocationsGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *V1LocationsGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1LocationsGet",
			OperationSummary: "List Locations",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *V1LocationsGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1LocationsGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1LocationsGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1LocationsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsGetRequest handles GET /v1/organizations operation.
//
// Returns a list of organizations the authenticated user owns or is a member of.
//
// GET /v1/organizations
func (s *Server) handleV1OrganizationsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response []Organization
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsGet",
			OperationSummary: "List Organizations",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = []Organization
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameAuditLogsGetRequest handles GET /v1/organizations/{organizationName}/audit-logs operation.
//
// Return the audit logs for the given organization, ordered by the `created_at` field in descending
// order.
//
// GET /v1/organizations/{organizationName}/audit-logs
func (s *Server) handleV1OrganizationsOrganizationNameAuditLogsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/audit-logs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameAuditLogsGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameAuditLogsGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameAuditLogsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *V1OrganizationsOrganizationNameAuditLogsGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameAuditLogsGet",
			OperationSummary: "List Audit Logs",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "page_size",
					In:   "query",
				}: params.PageSize,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameAuditLogsGetParams
			Response = *V1OrganizationsOrganizationNameAuditLogsGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameAuditLogsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameAuditLogsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameAuditLogsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameAuditLogsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostRequest handles POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate operation.
//
// Invalidates all authorization tokens for the specified database.
//
// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost",
			OperationSummary: "Invalidate All Database Auth Tokens",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "databaseName",
					In:   "path",
				}: params.DatabaseName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostParams
			Response = V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostRequest handles POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens operation.
//
// Generates an authorization token for the specified database.
//
// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost",
			OperationSummary: "Generate Database Auth Token",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "databaseName",
					In:   "path",
				}: params.DatabaseName,
				{
					Name: "expiration",
					In:   "query",
				}: params.Expiration,
				{
					Name: "authorization",
					In:   "query",
				}: params.Authorization,
			},
			Raw: r,
		}

		type (
			Request  = OptCreateTokenInput
			Params   = V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostParams
			Response = V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchRequest handles PATCH /v1/organizations/{organizationName}/databases/{databaseName}/configuration operation.
//
// Update a database configuration belonging to the organization or user.
//
// PATCH /v1/organizations/{organizationName}/databases/{databaseName}/configuration
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/configuration"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *DatabaseConfigurationResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch",
			OperationSummary: "Update Database Configuration",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "databaseName",
					In:   "path",
				}: params.DatabaseName,
			},
			Raw: r,
		}

		type (
			Request  = *DatabaseConfigurationInput
			Params   = V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchParams
			Response = *DatabaseConfigurationResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteRequest handles DELETE /v1/organizations/{organizationName}/databases/{databaseName} operation.
//
// Delete a database belonging to the organization or user.
//
// DELETE /v1/organizations/{organizationName}/databases/{databaseName}
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete",
			OperationSummary: "Delete Database",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "databaseName",
					In:   "path",
				}: params.DatabaseName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteParams
			Response = V1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDatabaseNameGetRequest handles GET /v1/organizations/{organizationName}/databases/{databaseName} operation.
//
// Returns a database belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDatabaseNameGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDatabaseNameGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDatabaseNameGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameDatabasesDatabaseNameGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDatabaseNameGet",
			OperationSummary: "Retrieve Database",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "databaseName",
					In:   "path",
				}: params.DatabaseName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameDatabasesDatabaseNameGetParams
			Response = V1OrganizationsOrganizationNameDatabasesDatabaseNameGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDatabaseNameGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetRequest handles GET /v1/organizations/{organizationName}/databases/{databaseName}/instances operation.
//
// Returns a list of instances of a database. Instances are the individual primary or replica
// databases in each region defined by the group.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/instances"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet",
			OperationSummary: "List Database Instances",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "databaseName",
					In:   "path",
				}: params.DatabaseName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetParams
			Response = *V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetRequest handles GET /v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName} operation.
//
// Return the individual database instance by name.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName}
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet",
			OperationSummary: "Retrieve Database Instance",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "databaseName",
					In:   "path",
				}: params.DatabaseName,
				{
					Name: "instanceName",
					In:   "path",
				}: params.InstanceName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetParams
			Response = *V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetRequest handles GET /v1/organizations/{organizationName}/databases/{databaseName}/stats operation.
//
// Fetch the top queries of a database, including the count of rows read and written.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/stats
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/stats"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet",
			OperationSummary: "Retrieve Database Stats",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "databaseName",
					In:   "path",
				}: params.DatabaseName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetParams
			Response = V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetRequest handles GET /v1/organizations/{organizationName}/databases/{databaseName}/usage operation.
//
// Fetch activity usage for a database in a given time period.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/usage
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/usage"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet",
			OperationSummary: "Retrieve Database Usage",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "databaseName",
					In:   "path",
				}: params.DatabaseName,
				{
					Name: "from",
					In:   "query",
				}: params.From,
				{
					Name: "to",
					In:   "query",
				}: params.To,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetParams
			Response = V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesDumpsPostRequest handles POST /v1/organizations/{organizationName}/databases/dumps operation.
//
// Upload a SQL dump to be used when [creating a new database](/api-reference/databases/create) from
// seed.
//
// POST /v1/organizations/{organizationName}/databases/dumps
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesDumpsPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/dumps"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesDumpsPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesDumpsPost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesDumpsPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNameDatabasesDumpsPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *V1OrganizationsOrganizationNameDatabasesDumpsPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesDumpsPost",
			OperationSummary: "Upload Dump",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = *V1OrganizationsOrganizationNameDatabasesDumpsPostReq
			Params   = V1OrganizationsOrganizationNameDatabasesDumpsPostParams
			Response = *V1OrganizationsOrganizationNameDatabasesDumpsPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesDumpsPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesDumpsPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesDumpsPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesDumpsPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesGetRequest handles GET /v1/organizations/{organizationName}/databases operation.
//
// Returns a list of databases belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/databases
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *V1OrganizationsOrganizationNameDatabasesGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesGet",
			OperationSummary: "List Databases",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameDatabasesGetParams
			Response = *V1OrganizationsOrganizationNameDatabasesGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameDatabasesPostRequest handles POST /v1/organizations/{organizationName}/databases operation.
//
// Creates a new database in a group for the organization or user.
//
// POST /v1/organizations/{organizationName}/databases
func (s *Server) handleV1OrganizationsOrganizationNameDatabasesPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameDatabasesPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameDatabasesPost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameDatabasesPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNameDatabasesPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response V1OrganizationsOrganizationNameDatabasesPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameDatabasesPost",
			OperationSummary: "Create Database",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = *CreateDatabaseInput
			Params   = V1OrganizationsOrganizationNameDatabasesPostParams
			Response = V1OrganizationsOrganizationNameDatabasesPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameDatabasesPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameDatabasesPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameDatabasesPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameDatabasesPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsGetRequest handles GET /v1/organizations/{organizationName}/groups operation.
//
// Returns a list of groups belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/groups
func (s *Server) handleV1OrganizationsOrganizationNameGroupsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *V1OrganizationsOrganizationNameGroupsGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsGet",
			OperationSummary: "List Groups",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameGroupsGetParams
			Response = *V1OrganizationsOrganizationNameGroupsGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostRequest handles POST /v1/organizations/{organizationName}/groups/{groupName}/auth/rotate operation.
//
// Invalidates all authorization tokens for the specified group.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/rotate
func (s *Server) handleV1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/auth/rotate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost",
			OperationSummary: "Invalidate All Group Auth Tokens",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "groupName",
					In:   "path",
				}: params.GroupName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostParams
			Response = V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostRequest handles POST /v1/organizations/{organizationName}/groups/{groupName}/auth/tokens operation.
//
// Generates an authorization token for the specified group.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/tokens
func (s *Server) handleV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/auth/tokens"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost",
			OperationSummary: "Create Group Auth Token",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "groupName",
					In:   "path",
				}: params.GroupName,
				{
					Name: "expiration",
					In:   "query",
				}: params.Expiration,
				{
					Name: "authorization",
					In:   "query",
				}: params.Authorization,
			},
			Raw: r,
		}

		type (
			Request  = OptCreateTokenInput
			Params   = V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostParams
			Response = V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsGroupNameDeleteRequest handles DELETE /v1/organizations/{organizationName}/groups/{groupName} operation.
//
// Delete a group belonging to the organization or user.
//
// DELETE /v1/organizations/{organizationName}/groups/{groupName}
func (s *Server) handleV1OrganizationsOrganizationNameGroupsGroupNameDeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsGroupNameDelete",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsGroupNameDelete",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameGroupsGroupNameDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsGroupNameDelete",
			OperationSummary: "Delete Group",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "groupName",
					In:   "path",
				}: params.GroupName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameGroupsGroupNameDeleteParams
			Response = V1OrganizationsOrganizationNameGroupsGroupNameDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsGroupNameDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsGroupNameGetRequest handles GET /v1/organizations/{organizationName}/groups/{groupName} operation.
//
// Returns a group belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/groups/{groupName}
func (s *Server) handleV1OrganizationsOrganizationNameGroupsGroupNameGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsGroupNameGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsGroupNameGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameGroupsGroupNameGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsGroupNameGet",
			OperationSummary: "Retrieve Group",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "groupName",
					In:   "path",
				}: params.GroupName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameGroupsGroupNameGetParams
			Response = V1OrganizationsOrganizationNameGroupsGroupNameGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsGroupNameGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteRequest handles DELETE /v1/organizations/{organizationName}/groups/{groupName}/locations/{location} operation.
//
// Removes a location from the specified group.
//
// DELETE /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
func (s *Server) handleV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/locations/{location}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete",
			OperationSummary: "Remove Location from Group",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "groupName",
					In:   "path",
				}: params.GroupName,
				{
					Name: "location",
					In:   "path",
				}: params.Location,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteParams
			Response = V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostRequest handles POST /v1/organizations/{organizationName}/groups/{groupName}/locations/{location} operation.
//
// Adds a location to the specified group.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
func (s *Server) handleV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/locations/{location}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost",
			OperationSummary: "Add Location to Group",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "groupName",
					In:   "path",
				}: params.GroupName,
				{
					Name: "location",
					In:   "path",
				}: params.Location,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostParams
			Response = V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsGroupNameTransferPostRequest handles POST /v1/organizations/{organizationName}/groups/{groupName}/transfer operation.
//
// Transfer a group to another organization that you own or a member of.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/transfer
func (s *Server) handleV1OrganizationsOrganizationNameGroupsGroupNameTransferPostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/transfer"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsGroupNameTransferPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsGroupNameTransferPost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameTransferPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNameGroupsGroupNameTransferPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response V1OrganizationsOrganizationNameGroupsGroupNameTransferPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsGroupNameTransferPost",
			OperationSummary: "Transfer Group",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "groupName",
					In:   "path",
				}: params.GroupName,
			},
			Raw: r,
		}

		type (
			Request  = *V1OrganizationsOrganizationNameGroupsGroupNameTransferPostReq
			Params   = V1OrganizationsOrganizationNameGroupsGroupNameTransferPostParams
			Response = V1OrganizationsOrganizationNameGroupsGroupNameTransferPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsGroupNameTransferPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameTransferPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameTransferPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameTransferPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsGroupNameUpdatePostRequest handles POST /v1/organizations/{organizationName}/groups/{groupName}/update operation.
//
// Updates all databases in the group to the latest libSQL version.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/update
func (s *Server) handleV1OrganizationsOrganizationNameGroupsGroupNameUpdatePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/update"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameUpdatePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameGroupsGroupNameUpdatePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost",
			OperationSummary: "Update Databases in a Group",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "groupName",
					In:   "path",
				}: params.GroupName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameGroupsGroupNameUpdatePostParams
			Response = V1OrganizationsOrganizationNameGroupsGroupNameUpdatePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsGroupNameUpdatePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameUpdatePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameGroupsPostRequest handles POST /v1/organizations/{organizationName}/groups operation.
//
// Creates a new group for the organization or user.
//
// POST /v1/organizations/{organizationName}/groups
func (s *Server) handleV1OrganizationsOrganizationNameGroupsPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameGroupsPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameGroupsPost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameGroupsPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNameGroupsPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response V1OrganizationsOrganizationNameGroupsPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameGroupsPost",
			OperationSummary: "Create Group",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = *NewGroup
			Params   = V1OrganizationsOrganizationNameGroupsPostParams
			Response = V1OrganizationsOrganizationNameGroupsPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameGroupsPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameGroupsPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameGroupsPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameGroupsPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameInvitesGetRequest handles GET /v1/organizations/{organizationName}/invites operation.
//
// Returns a list of invites for the organization.
//
// GET /v1/organizations/{organizationName}/invites
func (s *Server) handleV1OrganizationsOrganizationNameInvitesGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/invites"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameInvitesGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameInvitesGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameInvitesGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *V1OrganizationsOrganizationNameInvitesGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameInvitesGet",
			OperationSummary: "List Invites",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameInvitesGetParams
			Response = *V1OrganizationsOrganizationNameInvitesGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameInvitesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameInvitesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameInvitesGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameInvitesGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameInvitesPostRequest handles POST /v1/organizations/{organizationName}/invites operation.
//
// Invite a user to an organization.
//
// POST /v1/organizations/{organizationName}/invites
func (s *Server) handleV1OrganizationsOrganizationNameInvitesPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/invites"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameInvitesPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameInvitesPost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameInvitesPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNameInvitesPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *V1OrganizationsOrganizationNameInvitesPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameInvitesPost",
			OperationSummary: "Invite User",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = *V1OrganizationsOrganizationNameInvitesPostReq
			Params   = V1OrganizationsOrganizationNameInvitesPostParams
			Response = *V1OrganizationsOrganizationNameInvitesPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameInvitesPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameInvitesPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameInvitesPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameInvitesPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameMembersGetRequest handles GET /v1/organizations/{organizationName}/members operation.
//
// Returns a list of members part of the organization.
//
// GET /v1/organizations/{organizationName}/members
func (s *Server) handleV1OrganizationsOrganizationNameMembersGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameMembersGet",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameMembersGet",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameMembersGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *V1OrganizationsOrganizationNameMembersGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameMembersGet",
			OperationSummary: "List Members",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameMembersGetParams
			Response = *V1OrganizationsOrganizationNameMembersGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameMembersGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameMembersGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameMembersGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameMembersGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameMembersPostRequest handles POST /v1/organizations/{organizationName}/members operation.
//
// Add an existing Turso user to an organization.
//
// POST /v1/organizations/{organizationName}/members
func (s *Server) handleV1OrganizationsOrganizationNameMembersPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameMembersPost",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameMembersPost",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameMembersPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNameMembersPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response V1OrganizationsOrganizationNameMembersPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameMembersPost",
			OperationSummary: "Add Member",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = *V1OrganizationsOrganizationNameMembersPostReq
			Params   = V1OrganizationsOrganizationNameMembersPostParams
			Response = V1OrganizationsOrganizationNameMembersPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameMembersPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameMembersPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameMembersPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameMembersPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNameMembersUsernameDeleteRequest handles DELETE /v1/organizations/{organizationName}/members/{username} operation.
//
// Remove a user from the organization by username.
//
// DELETE /v1/organizations/{organizationName}/members/{username}
func (s *Server) handleV1OrganizationsOrganizationNameMembersUsernameDeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/members/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNameMembersUsernameDelete",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNameMembersUsernameDelete",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNameMembersUsernameDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response V1OrganizationsOrganizationNameMembersUsernameDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNameMembersUsernameDelete",
			OperationSummary: "Remove Member",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = V1OrganizationsOrganizationNameMembersUsernameDeleteParams
			Response = V1OrganizationsOrganizationNameMembersUsernameDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNameMembersUsernameDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNameMembersUsernameDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNameMembersUsernameDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNameMembersUsernameDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleV1OrganizationsOrganizationNamePatchRequest handles PATCH /v1/organizations/{organizationName} operation.
//
// Update an organization you own or are a member of.
//
// PATCH /v1/organizations/{organizationName}
func (s *Server) handleV1OrganizationsOrganizationNamePatchRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "V1OrganizationsOrganizationNamePatch",
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "V1OrganizationsOrganizationNamePatch",
			ID:   "",
		}
	)
	params, err := decodeV1OrganizationsOrganizationNamePatchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeV1OrganizationsOrganizationNamePatchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *V1OrganizationsOrganizationNamePatchOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "V1OrganizationsOrganizationNamePatch",
			OperationSummary: "Update Organization",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "organizationName",
					In:   "path",
				}: params.OrganizationName,
			},
			Raw: r,
		}

		type (
			Request  = *V1OrganizationsOrganizationNamePatchReq
			Params   = V1OrganizationsOrganizationNamePatchParams
			Response = *V1OrganizationsOrganizationNamePatchOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackV1OrganizationsOrganizationNamePatchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.V1OrganizationsOrganizationNamePatch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.V1OrganizationsOrganizationNamePatch(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeV1OrganizationsOrganizationNamePatchResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
