// Code generated by ogen, DO NOT EDIT.

package client

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// V1AuthAPITokensGet invokes GET /v1/auth/api-tokens operation.
	//
	// Returns a list of API tokens belonging to a user.
	//
	// GET /v1/auth/api-tokens
	V1AuthAPITokensGet(ctx context.Context) (*V1AuthAPITokensGetOK, error)
	// V1AuthAPITokensTokenNameDelete invokes DELETE /v1/auth/api-tokens/{tokenName} operation.
	//
	// Revokes the provided API token belonging to a user.
	//
	// DELETE /v1/auth/api-tokens/{tokenName}
	V1AuthAPITokensTokenNameDelete(ctx context.Context, params V1AuthAPITokensTokenNameDeleteParams) (jx.Raw, error)
	// V1AuthAPITokensTokenNamePost invokes POST /v1/auth/api-tokens/{tokenName} operation.
	//
	// Returns a new API token belonging to a user.
	//
	// POST /v1/auth/api-tokens/{tokenName}
	V1AuthAPITokensTokenNamePost(ctx context.Context, params V1AuthAPITokensTokenNamePostParams) (jx.Raw, error)
	// V1AuthValidateGet invokes GET /v1/auth/validate operation.
	//
	// Validates an API token belonging to a user.
	//
	// GET /v1/auth/validate
	V1AuthValidateGet(ctx context.Context) (*V1AuthValidateGetOK, error)
	// V1LocationsGet invokes GET /v1/locations operation.
	//
	// Returns a list of locations where you can create or replicate databases.
	//
	// GET /v1/locations
	V1LocationsGet(ctx context.Context) (*V1LocationsGetOK, error)
	// V1OrganizationsGet invokes GET /v1/organizations operation.
	//
	// Returns a list of organizations the authenticated user owns or is a member of.
	//
	// GET /v1/organizations
	V1OrganizationsGet(ctx context.Context) ([]Organization, error)
	// V1OrganizationsOrganizationNameAuditLogsGet invokes GET /v1/organizations/{organizationName}/audit-logs operation.
	//
	// Return the audit logs for the given organization, ordered by the `created_at` field in descending
	// order.
	//
	// GET /v1/organizations/{organizationName}/audit-logs
	V1OrganizationsOrganizationNameAuditLogsGet(ctx context.Context, params V1OrganizationsOrganizationNameAuditLogsGetParams) (*V1OrganizationsOrganizationNameAuditLogsGetOK, error)
	// V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost invokes POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate operation.
	//
	// Invalidates all authorization tokens for the specified database.
	//
	// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate
	V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostRes, error)
	// V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost invokes POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens operation.
	//
	// Generates an authorization token for the specified database.
	//
	// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens
	V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost(ctx context.Context, request OptCreateTokenInput, params V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostRes, error)
	// V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch invokes PATCH /v1/organizations/{organizationName}/databases/{databaseName}/configuration operation.
	//
	// Update a database configuration belonging to the organization or user.
	//
	// PATCH /v1/organizations/{organizationName}/databases/{databaseName}/configuration
	V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch(ctx context.Context, request *DatabaseConfigurationInput, params V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchParams) (*DatabaseConfigurationResponse, error)
	// V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete invokes DELETE /v1/organizations/{organizationName}/databases/{databaseName} operation.
	//
	// Delete a database belonging to the organization or user.
	//
	// DELETE /v1/organizations/{organizationName}/databases/{databaseName}
	V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteRes, error)
	// V1OrganizationsOrganizationNameDatabasesDatabaseNameGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName} operation.
	//
	// Returns a database belonging to the organization or user.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}
	V1OrganizationsOrganizationNameDatabasesDatabaseNameGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameGetParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameGetRes, error)
	// V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName}/instances operation.
	//
	// Returns a list of instances of a database. Instances are the individual primary or replica
	// databases in each region defined by the group.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances
	V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetParams) (*V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetOK, error)
	// V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName} operation.
	//
	// Return the individual database instance by name.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName}
	V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetParams) (*V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetOK, error)
	// V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName}/stats operation.
	//
	// Fetch the top queries of a database, including the count of rows read and written.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}/stats
	V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetRes, error)
	// V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName}/usage operation.
	//
	// Fetch activity usage for a database in a given time period.
	//
	// GET /v1/organizations/{organizationName}/databases/{databaseName}/usage
	V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetRes, error)
	// V1OrganizationsOrganizationNameDatabasesDumpsPost invokes POST /v1/organizations/{organizationName}/databases/dumps operation.
	//
	// Upload a SQL dump to be used when [creating a new database](/api-reference/databases/create) from
	// seed.
	//
	// POST /v1/organizations/{organizationName}/databases/dumps
	V1OrganizationsOrganizationNameDatabasesDumpsPost(ctx context.Context, request *V1OrganizationsOrganizationNameDatabasesDumpsPostReq, params V1OrganizationsOrganizationNameDatabasesDumpsPostParams) (*V1OrganizationsOrganizationNameDatabasesDumpsPostOK, error)
	// V1OrganizationsOrganizationNameDatabasesGet invokes GET /v1/organizations/{organizationName}/databases operation.
	//
	// Returns a list of databases belonging to the organization or user.
	//
	// GET /v1/organizations/{organizationName}/databases
	V1OrganizationsOrganizationNameDatabasesGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesGetParams) (*V1OrganizationsOrganizationNameDatabasesGetOK, error)
	// V1OrganizationsOrganizationNameDatabasesPost invokes POST /v1/organizations/{organizationName}/databases operation.
	//
	// Creates a new database in a group for the organization or user.
	//
	// POST /v1/organizations/{organizationName}/databases
	V1OrganizationsOrganizationNameDatabasesPost(ctx context.Context, request *CreateDatabaseInput, params V1OrganizationsOrganizationNameDatabasesPostParams) (V1OrganizationsOrganizationNameDatabasesPostRes, error)
	// V1OrganizationsOrganizationNameGroupsGet invokes GET /v1/organizations/{organizationName}/groups operation.
	//
	// Returns a list of groups belonging to the organization or user.
	//
	// GET /v1/organizations/{organizationName}/groups
	V1OrganizationsOrganizationNameGroupsGet(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGetParams) (*V1OrganizationsOrganizationNameGroupsGetOK, error)
	// V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/auth/rotate operation.
	//
	// Invalidates all authorization tokens for the specified group.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/rotate
	V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostParams) (V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostRes, error)
	// V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/auth/tokens operation.
	//
	// Generates an authorization token for the specified group.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/tokens
	V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost(ctx context.Context, request OptCreateTokenInput, params V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostParams) (V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostRes, error)
	// V1OrganizationsOrganizationNameGroupsGroupNameDelete invokes DELETE /v1/organizations/{organizationName}/groups/{groupName} operation.
	//
	// Delete a group belonging to the organization or user.
	//
	// DELETE /v1/organizations/{organizationName}/groups/{groupName}
	V1OrganizationsOrganizationNameGroupsGroupNameDelete(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameDeleteParams) (V1OrganizationsOrganizationNameGroupsGroupNameDeleteRes, error)
	// V1OrganizationsOrganizationNameGroupsGroupNameGet invokes GET /v1/organizations/{organizationName}/groups/{groupName} operation.
	//
	// Returns a group belonging to the organization or user.
	//
	// GET /v1/organizations/{organizationName}/groups/{groupName}
	V1OrganizationsOrganizationNameGroupsGroupNameGet(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameGetParams) (V1OrganizationsOrganizationNameGroupsGroupNameGetRes, error)
	// V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete invokes DELETE /v1/organizations/{organizationName}/groups/{groupName}/locations/{location} operation.
	//
	// Removes a location from the specified group.
	//
	// DELETE /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
	V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteParams) (V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteRes, error)
	// V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/locations/{location} operation.
	//
	// Adds a location to the specified group.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
	V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostParams) (V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostRes, error)
	// V1OrganizationsOrganizationNameGroupsGroupNameTransferPost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/transfer operation.
	//
	// Transfer a group to another organization that you own or a member of.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/transfer
	V1OrganizationsOrganizationNameGroupsGroupNameTransferPost(ctx context.Context, request *V1OrganizationsOrganizationNameGroupsGroupNameTransferPostReq, params V1OrganizationsOrganizationNameGroupsGroupNameTransferPostParams) (V1OrganizationsOrganizationNameGroupsGroupNameTransferPostRes, error)
	// V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/update operation.
	//
	// Updates all databases in the group to the latest libSQL version.
	//
	// POST /v1/organizations/{organizationName}/groups/{groupName}/update
	V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameUpdatePostParams) (V1OrganizationsOrganizationNameGroupsGroupNameUpdatePostRes, error)
	// V1OrganizationsOrganizationNameGroupsPost invokes POST /v1/organizations/{organizationName}/groups operation.
	//
	// Creates a new group for the organization or user.
	//
	// POST /v1/organizations/{organizationName}/groups
	V1OrganizationsOrganizationNameGroupsPost(ctx context.Context, request *NewGroup, params V1OrganizationsOrganizationNameGroupsPostParams) (V1OrganizationsOrganizationNameGroupsPostRes, error)
	// V1OrganizationsOrganizationNameInvitesGet invokes GET /v1/organizations/{organizationName}/invites operation.
	//
	// Returns a list of invites for the organization.
	//
	// GET /v1/organizations/{organizationName}/invites
	V1OrganizationsOrganizationNameInvitesGet(ctx context.Context, params V1OrganizationsOrganizationNameInvitesGetParams) (*V1OrganizationsOrganizationNameInvitesGetOK, error)
	// V1OrganizationsOrganizationNameInvitesPost invokes POST /v1/organizations/{organizationName}/invites operation.
	//
	// Invite a user to an organization.
	//
	// POST /v1/organizations/{organizationName}/invites
	V1OrganizationsOrganizationNameInvitesPost(ctx context.Context, request *V1OrganizationsOrganizationNameInvitesPostReq, params V1OrganizationsOrganizationNameInvitesPostParams) (*V1OrganizationsOrganizationNameInvitesPostOK, error)
	// V1OrganizationsOrganizationNameMembersGet invokes GET /v1/organizations/{organizationName}/members operation.
	//
	// Returns a list of members part of the organization.
	//
	// GET /v1/organizations/{organizationName}/members
	V1OrganizationsOrganizationNameMembersGet(ctx context.Context, params V1OrganizationsOrganizationNameMembersGetParams) (*V1OrganizationsOrganizationNameMembersGetOK, error)
	// V1OrganizationsOrganizationNameMembersPost invokes POST /v1/organizations/{organizationName}/members operation.
	//
	// Add an existing Turso user to an organization.
	//
	// POST /v1/organizations/{organizationName}/members
	V1OrganizationsOrganizationNameMembersPost(ctx context.Context, request *V1OrganizationsOrganizationNameMembersPostReq, params V1OrganizationsOrganizationNameMembersPostParams) (V1OrganizationsOrganizationNameMembersPostRes, error)
	// V1OrganizationsOrganizationNameMembersUsernameDelete invokes DELETE /v1/organizations/{organizationName}/members/{username} operation.
	//
	// Remove a user from the organization by username.
	//
	// DELETE /v1/organizations/{organizationName}/members/{username}
	V1OrganizationsOrganizationNameMembersUsernameDelete(ctx context.Context, params V1OrganizationsOrganizationNameMembersUsernameDeleteParams) (V1OrganizationsOrganizationNameMembersUsernameDeleteRes, error)
	// V1OrganizationsOrganizationNamePatch invokes PATCH /v1/organizations/{organizationName} operation.
	//
	// Update an organization you own or are a member of.
	//
	// PATCH /v1/organizations/{organizationName}
	V1OrganizationsOrganizationNamePatch(ctx context.Context, request *V1OrganizationsOrganizationNamePatchReq, params V1OrganizationsOrganizationNamePatchParams) (*V1OrganizationsOrganizationNamePatchOK, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// V1AuthAPITokensGet invokes GET /v1/auth/api-tokens operation.
//
// Returns a list of API tokens belonging to a user.
//
// GET /v1/auth/api-tokens
func (c *Client) V1AuthAPITokensGet(ctx context.Context) (*V1AuthAPITokensGetOK, error) {
	res, err := c.sendV1AuthAPITokensGet(ctx)
	return res, err
}

func (c *Client) sendV1AuthAPITokensGet(ctx context.Context) (res *V1AuthAPITokensGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/auth/api-tokens"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1AuthAPITokensGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/api-tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1AuthAPITokensGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1AuthAPITokensTokenNameDelete invokes DELETE /v1/auth/api-tokens/{tokenName} operation.
//
// Revokes the provided API token belonging to a user.
//
// DELETE /v1/auth/api-tokens/{tokenName}
func (c *Client) V1AuthAPITokensTokenNameDelete(ctx context.Context, params V1AuthAPITokensTokenNameDeleteParams) (jx.Raw, error) {
	res, err := c.sendV1AuthAPITokensTokenNameDelete(ctx, params)
	return res, err
}

func (c *Client) sendV1AuthAPITokensTokenNameDelete(ctx context.Context, params V1AuthAPITokensTokenNameDeleteParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/auth/api-tokens/{tokenName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1AuthAPITokensTokenNameDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/auth/api-tokens/"
	{
		// Encode "tokenName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tokenName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TokenName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1AuthAPITokensTokenNameDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1AuthAPITokensTokenNamePost invokes POST /v1/auth/api-tokens/{tokenName} operation.
//
// Returns a new API token belonging to a user.
//
// POST /v1/auth/api-tokens/{tokenName}
func (c *Client) V1AuthAPITokensTokenNamePost(ctx context.Context, params V1AuthAPITokensTokenNamePostParams) (jx.Raw, error) {
	res, err := c.sendV1AuthAPITokensTokenNamePost(ctx, params)
	return res, err
}

func (c *Client) sendV1AuthAPITokensTokenNamePost(ctx context.Context, params V1AuthAPITokensTokenNamePostParams) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/auth/api-tokens/{tokenName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1AuthAPITokensTokenNamePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/auth/api-tokens/"
	{
		// Encode "tokenName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tokenName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TokenName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1AuthAPITokensTokenNamePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1AuthValidateGet invokes GET /v1/auth/validate operation.
//
// Validates an API token belonging to a user.
//
// GET /v1/auth/validate
func (c *Client) V1AuthValidateGet(ctx context.Context) (*V1AuthValidateGetOK, error) {
	res, err := c.sendV1AuthValidateGet(ctx)
	return res, err
}

func (c *Client) sendV1AuthValidateGet(ctx context.Context) (res *V1AuthValidateGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/auth/validate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1AuthValidateGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/auth/validate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1AuthValidateGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1LocationsGet invokes GET /v1/locations operation.
//
// Returns a list of locations where you can create or replicate databases.
//
// GET /v1/locations
func (c *Client) V1LocationsGet(ctx context.Context) (*V1LocationsGetOK, error) {
	res, err := c.sendV1LocationsGet(ctx)
	return res, err
}

func (c *Client) sendV1LocationsGet(ctx context.Context) (res *V1LocationsGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/locations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1LocationsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/locations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1LocationsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsGet invokes GET /v1/organizations operation.
//
// Returns a list of organizations the authenticated user owns or is a member of.
//
// GET /v1/organizations
func (c *Client) V1OrganizationsGet(ctx context.Context) ([]Organization, error) {
	res, err := c.sendV1OrganizationsGet(ctx)
	return res, err
}

func (c *Client) sendV1OrganizationsGet(ctx context.Context) (res []Organization, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/organizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameAuditLogsGet invokes GET /v1/organizations/{organizationName}/audit-logs operation.
//
// Return the audit logs for the given organization, ordered by the `created_at` field in descending
// order.
//
// GET /v1/organizations/{organizationName}/audit-logs
func (c *Client) V1OrganizationsOrganizationNameAuditLogsGet(ctx context.Context, params V1OrganizationsOrganizationNameAuditLogsGetParams) (*V1OrganizationsOrganizationNameAuditLogsGetOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNameAuditLogsGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameAuditLogsGet(ctx context.Context, params V1OrganizationsOrganizationNameAuditLogsGetParams) (res *V1OrganizationsOrganizationNameAuditLogsGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/audit-logs"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameAuditLogsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audit-logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameAuditLogsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost invokes POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate operation.
//
// Invalidates all authorization tokens for the specified database.
//
// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate
func (c *Client) V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostParams) (res V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/auth/rotate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/auth/rotate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthRotatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost invokes POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens operation.
//
// Generates an authorization token for the specified database.
//
// POST /v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens
func (c *Client) V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost(ctx context.Context, request OptCreateTokenInput, params V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost(ctx context.Context, request OptCreateTokenInput, params V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostParams) (res V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/auth/tokens"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/auth/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "expiration" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "expiration",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Expiration.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "authorization" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "authorization",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Authorization.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameAuthTokensPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch invokes PATCH /v1/organizations/{organizationName}/databases/{databaseName}/configuration operation.
//
// Update a database configuration belonging to the organization or user.
//
// PATCH /v1/organizations/{organizationName}/databases/{databaseName}/configuration
func (c *Client) V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch(ctx context.Context, request *DatabaseConfigurationInput, params V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchParams) (*DatabaseConfigurationResponse, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch(ctx context.Context, request *DatabaseConfigurationInput, params V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchParams) (res *DatabaseConfigurationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/configuration"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/configuration"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameConfigurationPatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete invokes DELETE /v1/organizations/{organizationName}/databases/{databaseName} operation.
//
// Delete a database belonging to the organization or user.
//
// DELETE /v1/organizations/{organizationName}/databases/{databaseName}
func (c *Client) V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDatabaseNameDelete(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDatabaseNameDelete(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteParams) (res V1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDatabaseNameDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDatabaseNameGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName} operation.
//
// Returns a database belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}
func (c *Client) V1OrganizationsOrganizationNameDatabasesDatabaseNameGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameGetParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameGetRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDatabaseNameGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDatabaseNameGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameGetParams) (res V1OrganizationsOrganizationNameDatabasesDatabaseNameGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDatabaseNameGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName}/instances operation.
//
// Returns a list of instances of a database. Instances are the individual primary or replica
// databases in each region defined by the group.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances
func (c *Client) V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetParams) (*V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetParams) (res *V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/instances"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/instances"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName} operation.
//
// Return the individual database instance by name.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName}
func (c *Client) V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetParams) (*V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetParams) (res *V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/instances/{instanceName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/instances/"
	{
		// Encode "instanceName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameInstancesInstanceNameGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName}/stats operation.
//
// Fetch the top queries of a database, including the count of rows read and written.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/stats
func (c *Client) V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetParams) (res V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/stats"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameStatsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet invokes GET /v1/organizations/{organizationName}/databases/{databaseName}/usage operation.
//
// Fetch activity usage for a database in a given time period.
//
// GET /v1/organizations/{organizationName}/databases/{databaseName}/usage
func (c *Client) V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetParams) (V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetParams) (res V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/{databaseName}/usage"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/"
	{
		// Encode "databaseName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "databaseName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DatabaseName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/usage"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.From.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.To.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDatabaseNameUsageGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesDumpsPost invokes POST /v1/organizations/{organizationName}/databases/dumps operation.
//
// Upload a SQL dump to be used when [creating a new database](/api-reference/databases/create) from
// seed.
//
// POST /v1/organizations/{organizationName}/databases/dumps
func (c *Client) V1OrganizationsOrganizationNameDatabasesDumpsPost(ctx context.Context, request *V1OrganizationsOrganizationNameDatabasesDumpsPostReq, params V1OrganizationsOrganizationNameDatabasesDumpsPostParams) (*V1OrganizationsOrganizationNameDatabasesDumpsPostOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesDumpsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesDumpsPost(ctx context.Context, request *V1OrganizationsOrganizationNameDatabasesDumpsPostReq, params V1OrganizationsOrganizationNameDatabasesDumpsPostParams) (res *V1OrganizationsOrganizationNameDatabasesDumpsPostOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases/dumps"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesDumpsPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases/dumps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNameDatabasesDumpsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesDumpsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesGet invokes GET /v1/organizations/{organizationName}/databases operation.
//
// Returns a list of databases belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/databases
func (c *Client) V1OrganizationsOrganizationNameDatabasesGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesGetParams) (*V1OrganizationsOrganizationNameDatabasesGetOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesGet(ctx context.Context, params V1OrganizationsOrganizationNameDatabasesGetParams) (res *V1OrganizationsOrganizationNameDatabasesGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameDatabasesPost invokes POST /v1/organizations/{organizationName}/databases operation.
//
// Creates a new database in a group for the organization or user.
//
// POST /v1/organizations/{organizationName}/databases
func (c *Client) V1OrganizationsOrganizationNameDatabasesPost(ctx context.Context, request *CreateDatabaseInput, params V1OrganizationsOrganizationNameDatabasesPostParams) (V1OrganizationsOrganizationNameDatabasesPostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameDatabasesPost(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameDatabasesPost(ctx context.Context, request *CreateDatabaseInput, params V1OrganizationsOrganizationNameDatabasesPostParams) (res V1OrganizationsOrganizationNameDatabasesPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/databases"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameDatabasesPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/databases"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNameDatabasesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameDatabasesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsGet invokes GET /v1/organizations/{organizationName}/groups operation.
//
// Returns a list of groups belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/groups
func (c *Client) V1OrganizationsOrganizationNameGroupsGet(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGetParams) (*V1OrganizationsOrganizationNameGroupsGetOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsGet(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGetParams) (res *V1OrganizationsOrganizationNameGroupsGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/auth/rotate operation.
//
// Invalidates all authorization tokens for the specified group.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/rotate
func (c *Client) V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostParams) (V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostParams) (res V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/auth/rotate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/auth/rotate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameAuthRotatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/auth/tokens operation.
//
// Generates an authorization token for the specified group.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/auth/tokens
func (c *Client) V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost(ctx context.Context, request OptCreateTokenInput, params V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostParams) (V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost(ctx context.Context, request OptCreateTokenInput, params V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostParams) (res V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/auth/tokens"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/auth/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "expiration" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "expiration",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Expiration.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "authorization" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "authorization",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Authorization.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameAuthTokensPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsGroupNameDelete invokes DELETE /v1/organizations/{organizationName}/groups/{groupName} operation.
//
// Delete a group belonging to the organization or user.
//
// DELETE /v1/organizations/{organizationName}/groups/{groupName}
func (c *Client) V1OrganizationsOrganizationNameGroupsGroupNameDelete(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameDeleteParams) (V1OrganizationsOrganizationNameGroupsGroupNameDeleteRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsGroupNameDelete(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsGroupNameDelete(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameDeleteParams) (res V1OrganizationsOrganizationNameGroupsGroupNameDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsGroupNameDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsGroupNameGet invokes GET /v1/organizations/{organizationName}/groups/{groupName} operation.
//
// Returns a group belonging to the organization or user.
//
// GET /v1/organizations/{organizationName}/groups/{groupName}
func (c *Client) V1OrganizationsOrganizationNameGroupsGroupNameGet(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameGetParams) (V1OrganizationsOrganizationNameGroupsGroupNameGetRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsGroupNameGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsGroupNameGet(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameGetParams) (res V1OrganizationsOrganizationNameGroupsGroupNameGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsGroupNameGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete invokes DELETE /v1/organizations/{organizationName}/groups/{groupName}/locations/{location} operation.
//
// Removes a location from the specified group.
//
// DELETE /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
func (c *Client) V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteParams) (V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteParams) (res V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/locations/{location}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/locations/"
	{
		// Encode "location" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "location",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Location))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/locations/{location} operation.
//
// Adds a location to the specified group.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/locations/{location}
func (c *Client) V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostParams) (V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostParams) (res V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/locations/{location}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/locations/"
	{
		// Encode "location" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "location",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Location))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameLocationsLocationPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsGroupNameTransferPost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/transfer operation.
//
// Transfer a group to another organization that you own or a member of.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/transfer
func (c *Client) V1OrganizationsOrganizationNameGroupsGroupNameTransferPost(ctx context.Context, request *V1OrganizationsOrganizationNameGroupsGroupNameTransferPostReq, params V1OrganizationsOrganizationNameGroupsGroupNameTransferPostParams) (V1OrganizationsOrganizationNameGroupsGroupNameTransferPostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsGroupNameTransferPost(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsGroupNameTransferPost(ctx context.Context, request *V1OrganizationsOrganizationNameGroupsGroupNameTransferPostReq, params V1OrganizationsOrganizationNameGroupsGroupNameTransferPostParams) (res V1OrganizationsOrganizationNameGroupsGroupNameTransferPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/transfer"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsGroupNameTransferPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/transfer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNameGroupsGroupNameTransferPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameTransferPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost invokes POST /v1/organizations/{organizationName}/groups/{groupName}/update operation.
//
// Updates all databases in the group to the latest libSQL version.
//
// POST /v1/organizations/{organizationName}/groups/{groupName}/update
func (c *Client) V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameUpdatePostParams) (V1OrganizationsOrganizationNameGroupsGroupNameUpdatePostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsGroupNameUpdatePost(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsGroupNameUpdatePost(ctx context.Context, params V1OrganizationsOrganizationNameGroupsGroupNameUpdatePostParams) (res V1OrganizationsOrganizationNameGroupsGroupNameUpdatePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups/{groupName}/update"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsGroupNameUpdatePost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups/"
	{
		// Encode "groupName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/update"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsGroupNameUpdatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameGroupsPost invokes POST /v1/organizations/{organizationName}/groups operation.
//
// Creates a new group for the organization or user.
//
// POST /v1/organizations/{organizationName}/groups
func (c *Client) V1OrganizationsOrganizationNameGroupsPost(ctx context.Context, request *NewGroup, params V1OrganizationsOrganizationNameGroupsPostParams) (V1OrganizationsOrganizationNameGroupsPostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameGroupsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameGroupsPost(ctx context.Context, request *NewGroup, params V1OrganizationsOrganizationNameGroupsPostParams) (res V1OrganizationsOrganizationNameGroupsPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/groups"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameGroupsPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNameGroupsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameGroupsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameInvitesGet invokes GET /v1/organizations/{organizationName}/invites operation.
//
// Returns a list of invites for the organization.
//
// GET /v1/organizations/{organizationName}/invites
func (c *Client) V1OrganizationsOrganizationNameInvitesGet(ctx context.Context, params V1OrganizationsOrganizationNameInvitesGetParams) (*V1OrganizationsOrganizationNameInvitesGetOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNameInvitesGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameInvitesGet(ctx context.Context, params V1OrganizationsOrganizationNameInvitesGetParams) (res *V1OrganizationsOrganizationNameInvitesGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/invites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameInvitesGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameInvitesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameInvitesPost invokes POST /v1/organizations/{organizationName}/invites operation.
//
// Invite a user to an organization.
//
// POST /v1/organizations/{organizationName}/invites
func (c *Client) V1OrganizationsOrganizationNameInvitesPost(ctx context.Context, request *V1OrganizationsOrganizationNameInvitesPostReq, params V1OrganizationsOrganizationNameInvitesPostParams) (*V1OrganizationsOrganizationNameInvitesPostOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNameInvitesPost(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameInvitesPost(ctx context.Context, request *V1OrganizationsOrganizationNameInvitesPostReq, params V1OrganizationsOrganizationNameInvitesPostParams) (res *V1OrganizationsOrganizationNameInvitesPostOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/invites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameInvitesPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/invites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNameInvitesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameInvitesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameMembersGet invokes GET /v1/organizations/{organizationName}/members operation.
//
// Returns a list of members part of the organization.
//
// GET /v1/organizations/{organizationName}/members
func (c *Client) V1OrganizationsOrganizationNameMembersGet(ctx context.Context, params V1OrganizationsOrganizationNameMembersGetParams) (*V1OrganizationsOrganizationNameMembersGetOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNameMembersGet(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameMembersGet(ctx context.Context, params V1OrganizationsOrganizationNameMembersGetParams) (res *V1OrganizationsOrganizationNameMembersGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameMembersGet",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameMembersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameMembersPost invokes POST /v1/organizations/{organizationName}/members operation.
//
// Add an existing Turso user to an organization.
//
// POST /v1/organizations/{organizationName}/members
func (c *Client) V1OrganizationsOrganizationNameMembersPost(ctx context.Context, request *V1OrganizationsOrganizationNameMembersPostReq, params V1OrganizationsOrganizationNameMembersPostParams) (V1OrganizationsOrganizationNameMembersPostRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameMembersPost(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameMembersPost(ctx context.Context, request *V1OrganizationsOrganizationNameMembersPostReq, params V1OrganizationsOrganizationNameMembersPostParams) (res V1OrganizationsOrganizationNameMembersPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/members"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameMembersPost",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNameMembersPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameMembersPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNameMembersUsernameDelete invokes DELETE /v1/organizations/{organizationName}/members/{username} operation.
//
// Remove a user from the organization by username.
//
// DELETE /v1/organizations/{organizationName}/members/{username}
func (c *Client) V1OrganizationsOrganizationNameMembersUsernameDelete(ctx context.Context, params V1OrganizationsOrganizationNameMembersUsernameDeleteParams) (V1OrganizationsOrganizationNameMembersUsernameDeleteRes, error) {
	res, err := c.sendV1OrganizationsOrganizationNameMembersUsernameDelete(ctx, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNameMembersUsernameDelete(ctx context.Context, params V1OrganizationsOrganizationNameMembersUsernameDeleteParams) (res V1OrganizationsOrganizationNameMembersUsernameDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}/members/{username}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNameMembersUsernameDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNameMembersUsernameDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// V1OrganizationsOrganizationNamePatch invokes PATCH /v1/organizations/{organizationName} operation.
//
// Update an organization you own or are a member of.
//
// PATCH /v1/organizations/{organizationName}
func (c *Client) V1OrganizationsOrganizationNamePatch(ctx context.Context, request *V1OrganizationsOrganizationNamePatchReq, params V1OrganizationsOrganizationNamePatchParams) (*V1OrganizationsOrganizationNamePatchOK, error) {
	res, err := c.sendV1OrganizationsOrganizationNamePatch(ctx, request, params)
	return res, err
}

func (c *Client) sendV1OrganizationsOrganizationNamePatch(ctx context.Context, request *V1OrganizationsOrganizationNamePatchReq, params V1OrganizationsOrganizationNamePatchParams) (res *V1OrganizationsOrganizationNamePatchOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/v1/organizations/{organizationName}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "V1OrganizationsOrganizationNamePatch",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/organizations/"
	{
		// Encode "organizationName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "organizationName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrganizationName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeV1OrganizationsOrganizationNamePatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeV1OrganizationsOrganizationNamePatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
